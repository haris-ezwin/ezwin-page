---
import Container from "@components/container.astro";
import Layout from "@layouts/Layout.astro";
import { getFormattedDate } from "@utils/all";
import { getAllBlogPosts, getAllAuthors } from "@utils/prismic";
import type { BlogPostDocument, AuthorDocument } from "@utils/prismic";

type PrismicImage = { src: string; alt: string };

type AuthorInfo = {
  name: string;
  image: PrismicImage | null;
};

type BlogPostCard = {
  slug: string;
  title: string;
  publishDate: Date | null;
  image: PrismicImage | null;
  author: AuthorInfo | null;
};

type AuthorLookup = {
  byId: Map<string, AuthorDocument>;
  byUid: Map<string, AuthorDocument>;
};

const toPlainText = (field: unknown): string => {
  if (!field) return "";
  if (typeof field === "string") return field;
  if (Array.isArray(field)) {
    return field
      .map((block) => {
        if (
          typeof block === "object" &&
          block !== null &&
          "text" in block &&
          typeof (block as { text?: string }).text === "string"
        ) {
          return (block as { text?: string }).text ?? "";
        }
        return "";
      })
      .join(" ")
      .trim();
  }
  if (typeof field === "object" && field !== null) {
    const candidate = field as { text?: string };
    if (typeof candidate.text === "string") {
      return candidate.text;
    }
  }
  return "";
};

const normalizeImageField = (field: unknown): PrismicImage | null => {
  if (!field || typeof field !== "object") return null;
  const candidate = field as { url?: string; alt?: unknown };
  if (!candidate.url || typeof candidate.url !== "string") return null;

  return {
    src: candidate.url,
    alt: typeof candidate.alt === "string" ? candidate.alt : "",
  };
};

const pickImageField = (data: Record<string, any>) => {
  const imageKeys = ["featured_image", "cover_image", "image", "hero_image"];

  for (const key of imageKeys) {
    const value = data?.[key];
    const normalized = normalizeImageField(value);
    if (normalized) {
      return normalized;
    }
  }

  return null;
};

const toAuthorInfoFromData = (
  data?: Record<string, unknown>,
): AuthorInfo | null => {
  if (!data) return null;
  const name =
    toPlainText(data["name"]) ||
    toPlainText(data["full_name"]) ||
    toPlainText(data["title"]);
  const image =
    normalizeImageField(data["image"]) ||
    normalizeImageField(data["avatar"]) ||
    normalizeImageField(data["photo"]);

  if (!name && !image) return null;
  return { name, image };
};

const buildAuthorLookup = (authors: AuthorDocument[]): AuthorLookup => {
  const byId = new Map<string, AuthorDocument>();
  const byUid = new Map<string, AuthorDocument>();

  for (const author of authors) {
    byId.set(author.id, author);
    if (author.uid) {
      byUid.set(author.uid, author);
    }
  }

  return { byId, byUid };
};

const getAuthorInfoFromRelation = (
  candidate: unknown,
  lookup: AuthorLookup,
): AuthorInfo | null => {
  if (!candidate || typeof candidate !== "object") return null;

  const reference = candidate as {
    id?: string;
    uid?: string;
    data?: unknown;
  };

  if (reference.id && lookup.byId.has(reference.id)) {
    const doc = lookup.byId.get(reference.id)!;
    return toAuthorInfoFromData(doc.data ?? {});
  }

  if (reference.uid && lookup.byUid.has(reference.uid)) {
    const doc = lookup.byUid.get(reference.uid)!;
    return toAuthorInfoFromData(doc.data ?? {});
  }

  if (
    reference.data &&
    typeof reference.data === "object" &&
    reference.data !== null
  ) {
    return toAuthorInfoFromData(reference.data as Record<string, unknown>);
  }

  return null;
};

const resolveAuthorInfo = (
  post: BlogPostDocument,
  lookup: AuthorLookup,
): AuthorInfo | null => {
  const data = post.data ?? {};
  const relationshipCandidates: unknown[] = [];

  if (data.author) relationshipCandidates.push(data.author);

  if (Array.isArray(data.authors) && data.authors.length > 0) {
    const firstAuthor = data.authors[0];
    if (firstAuthor?.author) {
      relationshipCandidates.push(firstAuthor.author);
    }
    relationshipCandidates.push(firstAuthor);
  }

  if (data.primary?.author) relationshipCandidates.push(data.primary.author);

  for (const candidate of relationshipCandidates) {
    const info = getAuthorInfoFromRelation(candidate, lookup);
    if (info) return info;
  }

  const fallbackFields = [
    data.author_name,
    data.author_full_name,
    data.author,
    data.byline,
  ];

  for (const field of fallbackFields) {
    const text = toPlainText(field);
    if (text) {
      return { name: text, image: null };
    }
  }

  return null;
};

const [prismicPosts, authorDocs] = await Promise.all([
  getAllBlogPosts(),
  getAllAuthors(),
]);

console.log(authorDocs);

const authorLookup = buildAuthorLookup(authorDocs);

// Normalize Prismic documents into the shape needed by the UI.
const posts: BlogPostCard[] = prismicPosts
  .map((post) => {
    const publishDateValue = post.first_publication_date;

    return {
      slug: post.uid ?? post.slugs?.[0] ?? post.id,
      title: toPlainText(post.data?.title) || "Untitled post",
      publishDate: publishDateValue ? new Date(publishDateValue) : null,
      image: pickImageField(post.data ?? {}),
      author: resolveAuthorInfo(post, authorLookup),
    };
  })
  .filter((post) => Boolean(post.slug));

// Sort posts by publish date (newest first)
const sortedPosts = posts.sort(
  (a, b) => (b.publishDate?.valueOf() ?? 0) - (a.publishDate?.valueOf() ?? 0),
);
---

<Layout title="Blog | EzWin Academy">
  <Container>
    <div class="py-16 sm:py-20">
      <div class="text-center mb-12">
        <h1 class="text-4xl lg:text-5xl font-bold">Latest Blog Posts</h1>
        <p class="mt-4 text-lg text-gray-600">
          Tips, strategies, and insights for students and parents
        </p>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
        {
          sortedPosts.map((post) => (
            <a
              href={`/blog/${post.slug}`}
              class="group block bg-white rounded-2xl border border-gray-300 shadow-sm overflow-hidden hover:shadow-md transition-shadow focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-primary"
            >
              {post.image && (
                <div class="aspect-video">
                  <img
                    src={post.image.src}
                    alt={post.image.alt}
                    class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-[1.02]"
                  />
                </div>
              )}
              <div class="p-6">
                <h2 class="text-xl font-semibold text-gray-900 line-clamp-2 group-hover:text-primary">
                  {post.title}
                </h2>
                <div class="mt-4 text-sm text-gray-500">
                  {post.publishDate ? getFormattedDate(post.publishDate) : ""}
                </div>
              </div>
            </a>
          ))
        }
      </div>
    </div>
  </Container>
</Layout>
