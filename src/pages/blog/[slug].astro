---
import Layout from "@layouts/Layout.astro";
import Container from "@components/container.astro";
import { asHTML } from "@prismicio/helpers";
import { getFormattedDate } from "@utils/all";
import {
  getAllBlogPosts,
  getBlogPostByUID,
  getAllAuthors,
  type BlogPostDocument,
  type AuthorDocument,
} from "@utils/prismic";

type PrismicImage = { src: string; alt: string };

type AuthorInfo = {
  name: string;
  image: PrismicImage | null;
};

type AuthorLookup = {
  byId: Map<string, AuthorDocument>;
  byUid: Map<string, AuthorDocument>;
};

type NormalizedPost = {
  title: string;
  snippet: string;
  publishDate: Date | null;
  author: AuthorInfo | null;
  category: string;
  tags: string[];
  image: PrismicImage | null;
  contentHtml: string;
};

const toPlainText = (field: unknown): string => {
  if (!field) return "";
  if (typeof field === "string") return field;
  if (Array.isArray(field)) {
    return field
      .map((block) => {
        if (
          typeof block === "object" &&
          block !== null &&
          "text" in block &&
          typeof (block as { text?: string }).text === "string"
        ) {
          return (block as { text?: string }).text ?? "";
        }
        return "";
      })
      .join(" ")
      .trim();
  }
  if (typeof field === "object" && field !== null) {
    const candidate = field as { text?: string };
    if (typeof candidate.text === "string") {
      return candidate.text;
    }
  }
  return "";
};

const normalizeImageField = (field: unknown): PrismicImage | null => {
  if (!field || typeof field !== "object") return null;
  const candidate = field as { url?: string; alt?: unknown };
  if (!candidate.url || typeof candidate.url !== "string") return null;

  return {
    src: candidate.url,
    alt: typeof candidate.alt === "string" ? candidate.alt : "",
  };
};

const pickImageField = (data: Record<string, any>) => {
  const imageKeys = ["featured_image", "cover_image", "image", "hero_image"];

  for (const key of imageKeys) {
    const value = data?.[key];
    const normalized = normalizeImageField(value);
    if (normalized) return normalized;
  }

  return null;
};

const toHTML = (field: unknown): string => {
  if (!field) return "";
  if (typeof field === "string") return field;
  if (Array.isArray(field)) {
    return asHTML(field as any);
  }
  if (typeof field === "object" && field !== null) {
    const candidate = field as { richText?: unknown; text?: unknown };
    if (Array.isArray(candidate.richText)) {
      return asHTML(candidate.richText as any);
    }
    if (Array.isArray(candidate.text)) {
      return asHTML(candidate.text as any);
    }
  }
  return "";
};

const getTagList = (post: BlogPostDocument) => {
  if (Array.isArray(post.tags)) {
    return post.tags.filter((tag): tag is string => typeof tag === "string");
  }
  if (Array.isArray(post.data?.tags)) {
    return post.data.tags.filter((tag: unknown): tag is string => typeof tag === "string");
  }
  return [];
};

const toAuthorInfoFromData = (
  data?: Record<string, unknown>,
): AuthorInfo | null => {
  if (!data) return null;
  const name =
    toPlainText(data["name"]) ||
    toPlainText(data["full_name"]) ||
    toPlainText(data["title"]);
  const image =
    normalizeImageField(data["image"]) ||
    normalizeImageField(data["avatar"]) ||
    normalizeImageField(data["photo"]);

  if (!name && !image) return null;
  return { name, image };
};

const buildAuthorLookup = (authors: AuthorDocument[]): AuthorLookup => {
  const byId = new Map<string, AuthorDocument>();
  const byUid = new Map<string, AuthorDocument>();

  for (const author of authors) {
    byId.set(author.id, author);
    if (author.uid) {
      byUid.set(author.uid, author);
    }
  }

  return { byId, byUid };
};

const getAuthorInfoFromRelation = (
  candidate: unknown,
  lookup: AuthorLookup,
): AuthorInfo | null => {
  if (!candidate || typeof candidate !== "object") return null;

  const reference = candidate as {
    id?: string;
    uid?: string;
    data?: unknown;
  };

  if (reference.id && lookup.byId.has(reference.id)) {
    const doc = lookup.byId.get(reference.id)!;
    return toAuthorInfoFromData(doc.data ?? {});
  }

  if (reference.uid && lookup.byUid.has(reference.uid)) {
    const doc = lookup.byUid.get(reference.uid)!;
    return toAuthorInfoFromData(doc.data ?? {});
  }

  if (
    reference.data &&
    typeof reference.data === "object" &&
    reference.data !== null
  ) {
    return toAuthorInfoFromData(reference.data as Record<string, unknown>);
  }

  return null;
};

const resolveAuthorInfo = (
  post: BlogPostDocument,
  lookup: AuthorLookup,
): AuthorInfo | null => {
  const data = post.data ?? {};
  const relationshipCandidates: unknown[] = [];

  if (data.author) relationshipCandidates.push(data.author);

  if (Array.isArray(data.authors) && data.authors.length > 0) {
    const firstAuthor = data.authors[0];
    if (firstAuthor?.author) {
      relationshipCandidates.push(firstAuthor.author);
    }
    relationshipCandidates.push(firstAuthor);
  }

  if (data.primary?.author) relationshipCandidates.push(data.primary.author);

  for (const candidate of relationshipCandidates) {
    const info = getAuthorInfoFromRelation(candidate, lookup);
    if (info) return info;
  }

  const fallbackFields = [
    data.author_name,
    data.author_full_name,
    data.author,
    data.byline,
  ];

  for (const field of fallbackFields) {
    const text = toPlainText(field);
    if (text) {
      return { name: text, image: null };
    }
  }

  return null;
};

export async function getStaticPaths() {
  const posts = await getAllBlogPosts();

  return posts
    .filter((post) => Boolean(post.uid ?? post.slugs?.[0]))
    .map((post) => ({
      params: { slug: post.uid ?? post.slugs?.[0] ?? post.id },
    }));
}

const { slug } = Astro.params;

if (!slug) {
  throw Astro.redirect("/blog");
}

let post: BlogPostDocument | null = null;

try {
  post = await getBlogPostByUID(slug);
} catch {
  post = null;
}

if (!post) {
  throw Astro.redirect("/blog");
}

const authorDocs = await getAllAuthors();
const authorLookup = buildAuthorLookup(authorDocs);

const publishDateValue =
  post.data?.publishDate ??
  post.data?.publish_date ??
  post.first_publication_date ??
  post.last_publication_date ??
  null;

const normalizedPost: NormalizedPost = {
  title: toPlainText(post.data?.title) || "Untitled post",
  snippet:
    toPlainText(post.data?.snippet) ||
    toPlainText(post.data?.excerpt) ||
    toPlainText(post.data?.description) ||
    (typeof post.data?.meta_description === "string"
      ? post.data.meta_description
      : ""),
  publishDate: publishDateValue ? new Date(publishDateValue) : null,
  author: resolveAuthorInfo(post, authorLookup),
  category: toPlainText(post.data?.category),
  tags: getTagList(post),
  image: pickImageField(post.data ?? {}),
  contentHtml:
    toHTML(
      post.data?.content ??
        post.data?.body ??
        post.data?.rich_text ??
        post.data?.article_body ??
        [],
    ) || "",
};

const contentHtml =
  normalizedPost.contentHtml || "<p>No content available at the moment.</p>";
---

<Layout title={normalizedPost.title}>
  <Container>
    <div class="py-10">
      <article class="max-w-3xl mx-auto">
        <header class="mb-8">
          <a
            href="/blog"
            class="inline-flex items-center gap-2 text-primary font-medium hover:text-primary/80 mb-6"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-4 w-4"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round">
              <polyline points="15 18 9 12 15 6" />
            </svg>
            Back to Blog
          </a>
          <h1 class="text-4xl font-bold text-gray-800 mb-4">
            {normalizedPost.title}
          </h1>
          <div class="flex flex-wrap items-center gap-4 text-gray-600 mb-6">
            <span>
              {normalizedPost.publishDate
                ? getFormattedDate(normalizedPost.publishDate)
                : ""}
            </span>
            {normalizedPost.author && (
              <div class="flex items-center gap-3">
                <span class="text-gray-400">•</span>
                {normalizedPost.author.image && (
                  <img
                    src={normalizedPost.author.image.src}
                    alt={normalizedPost.author.image.alt}
                    class="h-10 w-10 rounded-full object-cover border border-gray-200"
                    loading="lazy"
                  />
                )}
                <span>By {normalizedPost.author.name || "Guest Author"}</span>
              </div>
            )}
            {
              normalizedPost.category && (
                <div class="flex items-center gap-2">
                  <span class="text-gray-400">•</span>
                  <span class="bg-primary/10 text-primary px-2 py-1 rounded-full text-sm">
                    {normalizedPost.category}
                  </span>
                </div>
              )
            }
          </div>
          {
            normalizedPost.snippet && (
              <p class="text-lg text-gray-600 italic">
                {normalizedPost.snippet}
              </p>
            )
          }
        </header>

        {
          normalizedPost.image && (
            <figure class="mb-8 rounded-2xl overflow-hidden border border-gray-200">
              <img
                src={normalizedPost.image.src}
                alt={normalizedPost.image.alt}
                class="w-full h-auto object-cover"
              />
            </figure>
          )
        }

        <div class="prose prose-lg max-w-none">
          <div set:html={contentHtml}></div>
        </div>

        {
          normalizedPost.tags.length > 0 && (
            <div class="mt-8 pt-6 border-t border-gray-200">
              <h3 class="text-sm font-semibold text-gray-700 mb-2">Tags:</h3>
              <div class="flex flex-wrap gap-2">
                {normalizedPost.tags.map((tag) => (
                  <span class="bg-gray-100 text-gray-700 px-3 py-1 rounded-full text-sm">
                    {tag}
                  </span>
                ))}
              </div>
            </div>
          )
        }
      </article>
    </div>
  </Container>
</Layout>

<style>
  .prose {
    color: #374151;
  }

  .prose iframe,
  .prose embed,
  .prose video {
    width: 100%;
    max-width: 100%;
    display: block;
    border: none;
    border-radius: 1rem;
  }

  .prose h1 {
    color: #111827;
    font-size: 2.25rem;
    font-weight: 700;
    margin-top: 2rem;
    margin-bottom: 1rem;
  }

  .prose h2 {
    color: #111827;
    font-size: 1.875rem;
    font-weight: 600;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
  }

  .prose h3 {
    color: #111827;
    font-size: 1.5rem;
    font-weight: 600;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
  }

  .prose p {
    margin-bottom: 1rem;
    line-height: 1.75;
  }

  .prose ul {
    margin-bottom: 1rem;
    padding-left: 1.5rem;
  }

  .prose li {
    margin-bottom: 0.5rem;
  }

  .prose strong {
    font-weight: 600;
    color: #111827;
  }

  .prose em {
    font-style: italic;
  }
</style>
