---
import Layout from "@layouts/Layout.astro";
import Container from "@components/container.astro";
import { asHTML } from "@prismicio/helpers";
import { getFormattedDate } from "@utils/all";
import {
  getAllBlogPosts,
  getBlogPostByUID,
  getAllAuthors,
  type BlogPostDocument,
  type AuthorDocument,
} from "@utils/prismic";

type PrismicImage = { src: string; alt: string };

type AuthorInfo = {
  name: string;
  image: PrismicImage | null;
};

type AuthorLookup = {
  byId: Map<string, AuthorDocument>;
  byUid: Map<string, AuthorDocument>;
};

type NormalizedPost = {
  title: string;
  snippet: string;
  publishDate: Date | null;
  author: AuthorInfo | null;
  category: string;
  tags: string[];
  image: PrismicImage | null;
  contentHtml: string;
};

const toPlainText = (field: unknown): string => {
  if (!field) return "";
  if (typeof field === "string") return field;
  if (Array.isArray(field)) {
    return field
      .map((block) => {
        if (
          typeof block === "object" &&
          block !== null &&
          "text" in block &&
          typeof (block as { text?: string }).text === "string"
        ) {
          return (block as { text?: string }).text ?? "";
        }
        return "";
      })
      .join(" ")
      .trim();
  }
  if (typeof field === "object" && field !== null) {
    const candidate = field as { text?: string };
    if (typeof candidate.text === "string") {
      return candidate.text;
    }
  }
  return "";
};

const normalizeImageField = (field: unknown): PrismicImage | null => {
  if (!field || typeof field !== "object") return null;
  const candidate = field as { url?: string; alt?: unknown };
  if (!candidate.url || typeof candidate.url !== "string") return null;

  return {
    src: candidate.url,
    alt: typeof candidate.alt === "string" ? candidate.alt : "",
  };
};

const pickImageField = (data: Record<string, any>) => {
  const imageKeys = ["featured_image", "cover_image", "image", "hero_image"];

  for (const key of imageKeys) {
    const value = data?.[key];
    const normalized = normalizeImageField(value);
    if (normalized) return normalized;
  }

  return null;
};

const toHTML = (field: unknown): string => {
  if (!field) return "";
  if (typeof field === "string") return field;
  if (Array.isArray(field)) {
    return asHTML(field as any);
  }
  if (typeof field === "object" && field !== null) {
    const candidate = field as { richText?: unknown; text?: unknown };
    if (Array.isArray(candidate.richText)) {
      return asHTML(candidate.richText as any);
    }
    if (Array.isArray(candidate.text)) {
      return asHTML(candidate.text as any);
    }
  }
  return "";
};

const getTagList = (post: BlogPostDocument) => {
  if (Array.isArray(post.tags)) {
    return post.tags.filter((tag): tag is string => typeof tag === "string");
  }
  if (Array.isArray(post.data?.tags)) {
    return post.data.tags.filter((tag: unknown): tag is string => typeof tag === "string");
  }
  return [];
};

const toAuthorInfoFromData = (
  data?: Record<string, unknown>,
): AuthorInfo | null => {
  if (!data) return null;
  const name =
    toPlainText(data["name"]) ||
    toPlainText(data["full_name"]) ||
    toPlainText(data["title"]);
  const image =
    normalizeImageField(data["image"]) ||
    normalizeImageField(data["avatar"]) ||
    normalizeImageField(data["photo"]);

  if (!name && !image) return null;
  return { name, image };
};

const buildAuthorLookup = (authors: AuthorDocument[]): AuthorLookup => {
  const byId = new Map<string, AuthorDocument>();
  const byUid = new Map<string, AuthorDocument>();

  for (const author of authors) {
    byId.set(author.id, author);
    if (author.uid) {
      byUid.set(author.uid, author);
    }
  }

  return { byId, byUid };
};

const getAuthorInfoFromRelation = (
  candidate: unknown,
  lookup: AuthorLookup,
): AuthorInfo | null => {
  if (!candidate || typeof candidate !== "object") return null;

  const reference = candidate as {
    id?: string;
    uid?: string;
    data?: unknown;
  };

  if (reference.id && lookup.byId.has(reference.id)) {
    const doc = lookup.byId.get(reference.id)!;
    return toAuthorInfoFromData(doc.data ?? {});
  }

  if (reference.uid && lookup.byUid.has(reference.uid)) {
    const doc = lookup.byUid.get(reference.uid)!;
    return toAuthorInfoFromData(doc.data ?? {});
  }

  if (
    reference.data &&
    typeof reference.data === "object" &&
    reference.data !== null
  ) {
    return toAuthorInfoFromData(reference.data as Record<string, unknown>);
  }

  return null;
};

const resolveAuthorInfo = (
  post: BlogPostDocument,
  lookup: AuthorLookup,
): AuthorInfo | null => {
  const data = post.data ?? {};
  const relationshipCandidates: unknown[] = [];

  if (data.author) relationshipCandidates.push(data.author);

  if (Array.isArray(data.authors) && data.authors.length > 0) {
    const firstAuthor = data.authors[0];
    if (firstAuthor?.author) {
      relationshipCandidates.push(firstAuthor.author);
    }
    relationshipCandidates.push(firstAuthor);
  }

  if (data.primary?.author) relationshipCandidates.push(data.primary.author);

  for (const candidate of relationshipCandidates) {
    const info = getAuthorInfoFromRelation(candidate, lookup);
    if (info) return info;
  }

  const fallbackFields = [
    data.author_name,
    data.author_full_name,
    data.author,
    data.byline,
  ];

  for (const field of fallbackFields) {
    const text = toPlainText(field);
    if (text) {
      return { name: text, image: null };
    }
  }

  return null;
};

export async function getStaticPaths() {
  const posts = await getAllBlogPosts();

  return posts
    .filter((post) => Boolean(post.uid ?? post.slugs?.[0]))
    .map((post) => ({
      params: { slug: post.uid ?? post.slugs?.[0] ?? post.id },
    }));
}

const { slug } = Astro.params;

if (!slug) {
  throw Astro.redirect("/blog");
}

let post: BlogPostDocument | null = null;

try {
  post = await getBlogPostByUID(slug);
} catch {
  post = null;
}

if (!post) {
  throw Astro.redirect("/blog");
}

const authorDocs = await getAllAuthors();
const authorLookup = buildAuthorLookup(authorDocs);

const publishDateValue =
  post.data?.publishDate ??
  post.data?.publish_date ??
  post.first_publication_date ??
  post.last_publication_date ??
  null;

const getPublishDate = (doc: BlogPostDocument) => {
  const dateValue =
    doc.data?.publishDate ??
    doc.data?.publish_date ??
    doc.first_publication_date ??
    doc.last_publication_date ??
    null;

  return dateValue ? new Date(dateValue) : null;
};

const normalizedPost: NormalizedPost = {
  title: toPlainText(post.data?.title) || "Untitled post",
  snippet:
    toPlainText(post.data?.snippet) ||
    toPlainText(post.data?.excerpt) ||
    toPlainText(post.data?.description) ||
    (typeof post.data?.meta_description === "string"
      ? post.data.meta_description
      : ""),
  publishDate: publishDateValue ? new Date(publishDateValue) : null,
  author: resolveAuthorInfo(post, authorLookup),
  category: toPlainText(post.data?.category),
  tags: getTagList(post),
  image: pickImageField(post.data ?? {}),
  contentHtml:
    toHTML(
      post.data?.content ??
        post.data?.body ??
        post.data?.rich_text ??
        post.data?.article_body ??
        [],
    ) || "",
};

const slugify = (text: string, counts: Map<string, number>) => {
  const base = text
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9\s-]/g, "")
    .replace(/\s+/g, "-");

  const safeBase = base || "section";
  const existingCount = counts.get(safeBase) ?? 0;
  counts.set(safeBase, existingCount + 1);

  return existingCount > 0 ? `${safeBase}-${existingCount + 1}` : safeBase;
};

const buildHeadings = (html: string) => {
  const headingRegex = /<h([1-4])([^>]*)>(.*?)<\/h\1>/gis;
  const counts = new Map<string, number>();
  const headings: { id: string; text: string; level: number }[] = [];
  let updatedHtml = html;
  let match: RegExpExecArray | null;

  while ((match = headingRegex.exec(html)) !== null) {
    const level = Number(match[1]);
    const attrs = match[2] || "";
    const inner = match[3] || "";
    const text = inner.replace(/<[^>]*>/g, "").trim();
    if (!text) continue;

    const idMatch = attrs.match(/id=["']([^"']+)["']/i);
    const id = idMatch?.[1] ?? slugify(text, counts);
    headings.push({ id, text, level });

    if (!idMatch) {
      const withId = `<h${level}${attrs} id="${id}">${inner}</h${level}>`;
      updatedHtml = updatedHtml.replace(match[0], withId);
    }
  }

  return { headings, html: updatedHtml };
};

const { headings, html: contentHtml } = buildHeadings(
  normalizedPost.contentHtml || "<p>No content available at the moment.</p>",
);

const recentPosts = (await getAllBlogPosts())
  .filter((p) => {
    const candidateSlug = p.uid ?? p.slugs?.[0] ?? p.id;
    return candidateSlug && candidateSlug !== slug;
  })
  .map((p) => {
    const candidateSlug = p.uid ?? p.slugs?.[0] ?? p.id;
    return {
      title: toPlainText(p.data?.title) || "Untitled post",
      slug: candidateSlug ?? "",
      date: getPublishDate(p),
      image: pickImageField(p.data ?? {}),
    };
  })
  .sort((a, b) => (b.date?.getTime() ?? 0) - (a.date?.getTime() ?? 0))
  .slice(0, 3);
---

<Layout title={normalizedPost.title}>
  <Container>
    <div class="py-10">
      <div class="lg:grid lg:grid-cols-[240px,1fr,320px] gap-10">
        <aside class="hidden lg:block">
          <div class="sticky top-24">
            <p class="text-sm font-semibold text-gray-700 mb-3">On this page</p>
            {headings.length === 0 && (
              <p class="text-sm text-gray-500">No section headings found.</p>
            )}
            {headings.length > 0 && (
              <nav class="space-y-2">
                {headings.map((heading) => (
                  <a
                    href={`#${heading.id}`}
                    class={`block text-sm text-gray-600 hover:text-primary ${
                      heading.level > 2 ? "pl-4" : ""
                    }`}
                  >
                    {heading.text}
                  </a>
                ))}
              </nav>
            )}
          </div>
        </aside>

        <article class="max-w-3xl lg:max-w-4xl">
          <header class="mb-8">
            <a
              href="/blog"
              class="inline-flex items-center gap-2 text-primary font-medium hover:text-primary/80 mb-6"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                class="h-4 w-4"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round">
                <polyline points="15 18 9 12 15 6" />
              </svg>
              Back to Blog
            </a>
            <h1 class="text-4xl font-bold text-gray-800 mb-4">
              {normalizedPost.title}
            </h1>
            <div class="flex flex-wrap items-center gap-4 text-gray-600 mb-6">
              <span>
                {normalizedPost.publishDate
                  ? getFormattedDate(normalizedPost.publishDate)
                  : ""}
              </span>
              {normalizedPost.author && (
                <div class="flex items-center gap-3">
                  <span class="text-gray-400">•</span>
                  {normalizedPost.author.image && (
                    <img
                      src={normalizedPost.author.image.src}
                      alt={normalizedPost.author.image.alt}
                      class="h-10 w-10 rounded-full object-cover border border-gray-200"
                      loading="lazy"
                    />
                  )}
                  <span>By {normalizedPost.author.name || "Guest Author"}</span>
                </div>
              )}
              {
                normalizedPost.category && (
                  <div class="flex items-center gap-2">
                    <span class="text-gray-400">•</span>
                    <span class="bg-primary/10 text-primary px-2 py-1 rounded-full text-sm">
                      {normalizedPost.category}
                    </span>
                  </div>
                )
              }
            </div>
            {
              normalizedPost.snippet && (
                <p class="text-lg text-gray-600 italic">
                  {normalizedPost.snippet}
                </p>
              )
            }
          </header>

          {
            normalizedPost.image && (
              <figure class="mb-8 rounded-2xl overflow-hidden border border-gray-200">
                <img
                  src={normalizedPost.image.src}
                  alt={normalizedPost.image.alt}
                  class="w-full h-auto object-cover"
                />
              </figure>
            )
          }

          <div class="prose prose-lg max-w-none">
            <div set:html={contentHtml}></div>
          </div>

          {
            normalizedPost.tags.length > 0 && (
              <div class="mt-8 pt-6 border-t border-gray-200">
                <h3 class="text-sm font-semibold text-gray-700 mb-2">Tags:</h3>
                <div class="flex flex-wrap gap-2">
                  {normalizedPost.tags.map((tag) => (
                    <span class="bg-gray-100 text-gray-700 px-3 py-1 rounded-full text-sm">
                      {tag}
                    </span>
                  ))}
                </div>
              </div>
            )
          }
        </article>

        <aside class="hidden lg:block">
          <div class="sticky top-24">
            <p class="text-sm font-semibold text-gray-700 mb-3">Recent posts</p>
            {recentPosts.length === 0 && (
              <p class="text-sm text-gray-500">No other posts available.</p>
            )}
            {recentPosts.length > 0 && (
              <div class="space-y-3">
                {recentPosts.map((recent) => (
                  <a
                    href={`/blog/${recent.slug}`}
                    target="_blank"
                    rel="noreferrer"
                    class="block p-3 rounded-lg border border-gray-200 hover:border-primary hover:bg-primary/5 transition-colors"
                  >
                    <div class="flex gap-3 items-start">
                      {recent.image ? (
                        <img
                          src={recent.image.src}
                          alt={recent.image.alt || recent.title}
                          class="h-14 w-14 rounded-md object-cover flex-shrink-0 border border-gray-200"
                          loading="lazy"
                        />
                      ) : (
                        <div class="h-14 w-14 rounded-md bg-gray-100 border border-gray-200 flex-shrink-0"></div>
                      )}
                      <div class="min-w-0">
                        <div class="text-sm font-semibold text-gray-800">
                          {recent.title}
                        </div>
                        <div class="text-xs text-gray-500 mt-1">
                          {recent.date ? getFormattedDate(recent.date) : ""}
                        </div>
                      </div>
                    </div>
                  </a>
                ))}
              </div>
            )}
          </div>
        </aside>
      </div>
    </div>
  </Container>
</Layout>

<script>
  const setScrollOffset = () => {
    const header = document.getElementById("site-header");
    const offset = (header?.offsetHeight ?? 0) + 12;
    const offsetValue = `${offset}px`;
    const root = document.documentElement;
    root.style.setProperty("--scroll-offset", offsetValue);
    root.style.scrollPaddingTop = offsetValue;
  };

  if (typeof window !== "undefined") {
    window.addEventListener("load", setScrollOffset);
    window.addEventListener("resize", setScrollOffset);
    setScrollOffset();
  }
</script>

<style>
  :global(:root) {
    scroll-padding-top: var(--scroll-offset, 96px);
  }

  .prose {
    color: #374151;
  }

  .prose iframe,
  .prose embed,
  .prose video {
    width: 100%;
    max-width: 100%;
    display: block;
    border: none;
    border-radius: 1rem;
  }

  .prose h1 {
    color: #111827;
    font-size: 2.25rem;
    font-weight: 700;
    margin-top: 2rem;
    margin-bottom: 1rem;
    scroll-margin-top: var(--scroll-offset, 96px);
  }

  .prose h2 {
    color: #111827;
    font-size: 1.875rem;
    font-weight: 600;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
    scroll-margin-top: var(--scroll-offset, 96px);
  }

  .prose h3 {
    color: #111827;
    font-size: 1.5rem;
    font-weight: 600;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
    scroll-margin-top: var(--scroll-offset, 96px);
  }

  .prose h4 {
    scroll-margin-top: var(--scroll-offset, 96px);
  }

  .prose p {
    margin-bottom: 1rem;
    line-height: 1.75;
  }

  .prose ul {
    margin-bottom: 1rem;
    padding-left: 1.5rem;
  }

  .prose li {
    margin-bottom: 0.5rem;
  }

  .prose strong {
    font-weight: 600;
    color: #111827;
  }

  .prose em {
    font-style: italic;
  }
</style>
